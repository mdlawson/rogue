<!DOCTYPE html><html><head><title>rogue</title><link rel="stylesheet" href="style/bootstrap.css"><link rel="stylesheet" href="style/style.css"><link rel="stylesheet" href="style/prettify.css"></head><body><div class="sidebar"><ul class="nav nav-list"><li class="nav-file"><a href="gfx.html">gfx</a><ul></ul></li><li class="nav-file"><a href="assets.html">assets</a><ul></ul></li><li class="nav-file"><a href="entity.html">entity</a><ul></ul></li><li class="nav-file"><a href="physics.html">physics</a><ul></ul></li><li class="nav-file"><a href="tiles.html">tiles</a><ul></ul></li><li class="nav-file"><a href="input.html">input</a><ul></ul></li><li class="nav-file"><a href="collision.html">collision</a><ul></ul></li><li class="nav-file"><a href="rogue.html">rogue</a><ul><li class="nav-header"><a href="#Game">Game</a><ul><li><a href="#Game.constructor">constructor</a></li><li><a href="#Game.start">start</a></li><li><a href="#Game.switchState">switchState</a></li><li><a href="#Game.clear">clear</a></li><li><a href="#Game.find">find</a></li></ul></li><li class="nav-header"><a href="#GameLoop">GameLoop</a><ul></ul></li><li class="nav-header"><a href="#ViewPort">ViewPort</a><ul><li><a href="#ViewPort.constructor">constructor</a></li><li><a href="#ViewPort.add">add</a></li><li><a href="#ViewPort.remove">remove</a></li><li><a href="#ViewPort.update">update</a></li><li><a href="#ViewPort.move">move</a></li><li><a href="#ViewPort.moveTo">moveTo</a></li><li><a href="#ViewPort.follow">follow</a></li><li><a href="#ViewPort.forceInside">forceInside</a></li><li><a href="#ViewPort.rect">rect</a></li><li><a href="#ViewPort.visible">visible</a></li><li><a href="#ViewPort.find">find</a></li></ul></li><li class="nav-header"><a href="#log">log</a><ul></ul></li><li class="nav-header"><a href="#Rogue.ready">ready</a><ul></ul></li></ul></li></ul></div><div class="container"><header><h1>rogue</h1></header><dl class="doc"><dt id="Game">class Game</dt><dd><p><p>Base class on which the game is built. Provides basic state management functionality.
Instances of game have canvas, context, and loop, which is an instance of GameLoop, properties</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class Game
  </pre><dl class="doc"><dt id="Game.constructor">constructor()</dt><dd><p><p>Game constructor</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>options </b><code>Object</code><span>	game setup options</span></p><ul></ul><li><b>canvas </b><code>String</code><span>	an ID of a canvas element provided, one will be created if not</span></li><li><b>width </b><code>Int</code><span>	width of canvas, defaults to 400</span></li><li><b>height </b><code>Int</code><span>	height of canvas, defaults to 300</span></li><li><b>showfps </b><code>Bool</code><span>	whether fps should be displayed</span></li></dd></dl><pre class="prettyprint language-coffee">constructor: (@options={}) ->
  @canvas = document.getElementById(options.canvas) if @options.canvas?
  if not @canvas?
    @canvas = util.canvas()
    document.body.appendChild(@canvas)
  @canvas.tabIndex=0
  @canvas.style.outline="none"
  @width = @canvas.width = @options.width ? 400
  @height = @canvas.height = @options.height ? 300
  @showFPS = @options.fps ? false
  @canvas.x = @canvas.y = 0
  @context = @canvas.getContext('2d')</pre><dl class="doc"></dl></dd><dt id="Game.start">start()</dt><dd><p><p>Starts the game with a state</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>state </b><code>Object</code><span>	game state</span></p><ul></ul><li><b>setup </b><code>Function</code><span>	function to run when state is initialised</span></li><li><b>update </b><code>Function</code><span>	function to run every tick in which game logic is performed. is passed dt, the change in time since the last tick.</span></li><li><b>draw </b><code>Function</code><span>	function to run every tick in which the game graphics are drawn</span></li></dd></dl><pre class="prettyprint language-coffee">start: (state) ->
  loading = @options.loadingScreen ? ->
  @switchState(state)</pre><dl class="doc"></dl></dd><dt id="Game.switchState">switchState()</dt><dd><p><p>Switches the state to a new state, saving the old state in game.oldState</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>state </b><code>Object</code><span>	state to switch to</span></p></dd></dl><pre class="prettyprint language-coffee">switchState: (state) ->
  @e = []
  @loop and @loop.stop()
  @oldState = @state
  @state = state
  @state.setup.call(@state,@)
  @loop = new GameLoop @,@showFPS
  @loop.add [@state.update,@state.draw]
  @loop.start()</pre><dl class="doc"></dl></dd><dt id="Game.clear">clear()</dt><dd><p><p>Clears the canvas, can be run at the end of each frame.</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">clear: ->
  @context.clearRect(0,0,@width,@height)</pre><dl class="doc"></dl></dd><dt id="Game.find">find()</dt><dd><p><p>Finds entities with a given set of components that are children of the game</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>components </b><code>Array</code><span>	array of components to match against</span></p><p> <b>ex </b><code>Entity</code><span>	an entity to exclude from the matching</span></p></dd><dt>Returns:</dt><dd><code>Array</code><span>	array of matched entities</span></dd></dl><pre class="prettyprint language-coffee">find: (components,ex) ->
  find.call(@,components,ex)</pre><dl class="doc"></dl></dd></dl></dd><dt id="GameLoop">class GameLoop</dt><dd><p><p>Gameloop class, used internally by Game, gets bound to game.loop
Runs functions in @call at 60fps</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class GameLoop
  constructor: (@parent,@showFPS) ->
    @fps = 0
    @averageFPS = new RollingAverage 20
    @call = []
  # Starts the loop, running each function in @call every tick
  start: ->
    @paused = @stopped = false
    firstTick = currentTick = lastTick = (new Date()).getTime()
    Rogue.ticker.call window, @loop
  # loop function that is called every tick
  loop: =>
    @currentTick = (new Date()).getTime()
    @dt = (@currentTick - @lastTick) or 17
    @fps = @averageFPS.add(1000/@dt)
    unless @stopped or @paused
      if @dt > 20 then @dt = 17
      func.call(@parent.state,@parent,@dt/1000) for func in @call
    unless @stopped
      Rogue.ticker.call window, @loop
    if @showFPS then @parent.context.fillText("fps:#{@fps} step:#{@dt}",10,10)
    @lastTick = @currentTick
  # Pauses the game loop, loop still runs, but no functions are called
  pause: -> 
    @paused = !@paused
  # Stops the game loop
  stop: ->
    @stopped = true</pre><dl class="doc"></dl></dd><dt id="ViewPort">class ViewPort</dt><dd><p><p>Viewport class, most games will use this. 
Expands the game world to be larger than the canvas.</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class ViewPort</pre><dl class="doc"><dt id="ViewPort.constructor">constructor()</dt><dd><p><p>ViewPort constructor</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>options </b><code>Object</code><span>	options for setting up the viewport</span></p><ul></ul><li><b>parent </b><code>Game</code><span>	the parent game instance to attach the viewport to</span></li><li><b>canvas </b><code>Canvas</code><span>	the canvas this viewport should render on, defaults to the parents canvas</span></li><li><b>width </b><code>Int</code><span>	the width of the viewport, defaults to the canvas width</span></li><li><b>height </b><code>Int</code><span>	the height of the viewport, defaults to the canvas height</span></li><li><b>viewWidth </b><code>Int</code><span>	the width of the viewable area, defaults to width</span></li><li><b>viewHeight </b><code>Int</code><span>	the height of the viewable area, defaults to height</span></li></dd></dl><pre class="prettyprint language-coffee">constructor: (@options) ->
  @parent = @options.parent
  @canvas = @options.canvas or @parent.canvas or util.canvas()
  @context = @canvas.getContext('2d')
  @width = @options.width or @canvas.width
  @height = @options.height or @canvas.height
  @viewWidth = @options.viewWidth or @width
  @viewHeight = @options.viewHeight or @height
  @viewX = @options.viewX or 0
  @viewY = @options.viewY or 0
  @x = @options.x or 0
  @y = @options.y or 0
  @e = []
  @hashmap = new collision.SpatialHash 64
  updateHash = ->
    solid = @find ["collide"]
    @hashmap.clear()
    @hashmap.add ent for ent in solid
  @updates = [updateHash]</pre><dl class="doc"></dl></dd><dt id="ViewPort.add">add()</dt><dd><p><p>Add an entity or an array of entities to the viewport, will be updated and rendered with the viewport, 
and position is drawn relative to the viewports position</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>entity </b><code>Entity</code><span>	entity to add, alternitively an array of entities can be given.</span></p></dd></dl><pre class="prettyprint language-coffee">add: (entity) ->
  if entity.forEach
    entity.forEach (obj) => @add obj
  else
    entity.parent = @
    @e.push(entity)
    @parent.e.push(entity)
    if entity.name? then @[entity.name] = entity</pre><dl class="doc"></dl></dd><dt id="ViewPort.remove">remove()</dt><dd><p><p>Remove an entity or an array of entities from the viewport, will no longer be updated and rendered with the viewport.</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>entity </b><code>Entity</code><span>	entity to remove, alternitively an array of entities can be given.</span></p></dd></dl><pre class="prettyprint language-coffee">remove: (entity) ->
  if entity.forEach
    entity.forEach (obj) => @remove obj
  else
    if entity.name? then delete @[entity.name]
    util.remove @e,entity
    util.remove @parent.e,entity
    delete entity.parent</pre><dl class="doc"></dl></dd><dt id="ViewPort.update">update()</dt><dd><p><p>Updates all entities within the viewport. The viewport update function should be called from your states update function</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>dt </b><code>Float</code><span>	dt, the time elapsed between ticks. all update functions should be passed dt.</span></p></dd></dl><pre class="prettyprint language-coffee">update: (dt) ->
  func.call(@,dt) for func in @updates when func?
  for entity in @e
    if @close(entity) and entity.update?
      entity.update(dt)
  </pre><dl class="doc"></dl></dd><dt id="ViewPort.move">move()</dt><dd><p><p>moves the view area by [x,y]</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>x </b><code>Int</code><span>	</span></p><p> <b>y </b><code>Int</code><span>	</span></p></dd></dl><pre class="prettyprint language-coffee">move: (x,y) ->
  @viewX += x
  @viewY += y
  @keepInBounds()</pre><dl class="doc"></dl></dd><dt id="ViewPort.moveTo">moveTo()</dt><dd><p><p>moves the view area to [x,y]</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>x </b><code>Int</code><span>	</span></p><p> <b>y </b><code>Int</code><span>	</span></p></dd></dl><pre class="prettyprint language-coffee">moveTo: (x,y) ->
  @viewX = x
  @viewY = y
  @keepInBounds()</pre><dl class="doc"></dl></dd><dt id="ViewPort.follow">follow()</dt><dd><p><p>Makes the view follow an entity, so that entity is always in the center</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>entity </b><code>Entity</code><span>	the entity to follow</span></p></dd></dl><pre class="prettyprint language-coffee">follow: (entity) ->
  @viewX = entity.x - math.round(@width/2)
  @viewY = entity.y - math.round(@height/2)
  @keepInBounds()</pre><dl class="doc"></dl></dd><dt id="ViewPort.forceInside">forceInside()</dt><dd><p><p>prevents an entity from going outside of the view area.</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>entity </b><code>Entity</code><span>	the entity to force inside</span></p><p> <b>buffer </b><code>Int</code><span>	the minimum distance an entity can be from the edge of the view area, defaults to 0</span></p></dd></dl><pre class="prettyprint language-coffee">forceInside: (entity, buffer=0) ->
  w = @viewWidth; h = @viewHeight
  if entity.x < buffer then entity.x = buffer
  if entity.y < buffer then entity.y = buffer
  if entity.x > w-buffer then entity.x = w-buffer
  if entity.y > h-buffer then entity.y = h-buffer</pre><dl class="doc"></dl></dd><dt id="ViewPort.rect">rect()</dt><dd><p><p>used for checking the visibility of objects</p>
</p><dl class="dl-horizontal"><dt>Returns:</dt><dd><code>Rect</code><span>	a rectangle object of the currently visible area</span></dd></dl><pre class="prettyprint language-coffee">rect: ->
  width: @width
  height: @height
  x: @viewX
  y: @viewY</pre><dl class="doc"></dl></dd><dt id="ViewPort.visible">visible()</dt><dd><p><p>Checks if an entity is currently visible.</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>entity </b><code>Entity</code><span>	</span></p></dd><dt>Returns:</dt><dd><code>Bool</code><span>	true if the entity is visible</span></dd></dl><pre class="prettyprint language-coffee">visible: (entity) ->
  collision.AABB entity.rect(), @rect()</pre><dl class="doc"></dl></dd><dt id="ViewPort.find">find()</dt><dd><p><p>@see Game.find</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">find: (components,ex) ->
  find.call(@,components,ex)</pre><dl class="doc"></dl></dd></dl></dd><dt id="log">log()</dt><dd><p><p>Logging function. uses Rogue.loglevel to determine which logs should be displayed.
1: error
2: warning
3: info
4: debug
All logs with numbers less than the current log level will be displayed.</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>level </b><code>Int</code><span>	loglevel of this log</span></p></dd></dl><pre class="prettyprint language-coffee">log = (level, args...) ->
  return unless level <= Rogue.loglevel
  switch level
    when 1 then func = console.error or console.log
    when 2 then func = console.warn or console.log
    when 3 then func = console.info or console.log
    when 4 then func = console.debug or console.log
  func.call(console,"(Rogue)", args...)</pre><dl class="doc"></dl></dd><dt id="Rogue.ready">Rogue.ready()</dt><dd><p><p>Calls a function when the DOM is ready</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>f </b><code>Function</code><span>	function to call</span></p></dd></dl><pre class="prettyprint language-coffee">Rogue.ready = (f) -> document.addEventListener "DOMContentLoaded", ->
  document.removeEventListener "DOMContentLoaded", arguments.callee, false
  f()</pre><dl class="doc"></dl></dd></dl></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script><script src="libs/prettify.js"></script><script>$(function(){prettyPrint()})
</script></body></html>