<!DOCTYPE html><html><head><title>entity</title><link rel="stylesheet" href="style/bootstrap.css"><link rel="stylesheet" href="style/style.css"><link rel="stylesheet" href="style/prettify.css"></head><body><div class="sidebar"><ul class="nav nav-list"><li class="nav-file"><a href="gfx.html">gfx</a><ul></ul></li><li class="nav-file"><a href="assets.html">assets</a><ul></ul></li><li class="nav-file"><a href="entity.html">entity</a><ul><li class="nav-header"><a href="#Entity">Entity</a><ul><li><a href="#Entity.constructor">constructor</a></li></ul></li><li class="nav-header"><a href="#Importer">Importer</a><ul></ul></li><li class="nav-header"><a href="#Factory">Factory</a><ul><li><a href="#Factory.constructor">constructor</a></li><li><a href="#Factory.deploy">deploy</a></li></ul></li><li class="nav-header"><a href="#c.sprite">c.sprite</a><ul><li><a href="#c.sprite.draw">draw</a></li><li><a href="#c.sprite.scale">scale</a></li><li><a href="#c.sprite.rect">rect</a></li></ul></li><li class="nav-header"><a href="#c.move">c.move</a><ul><li><a href="#c.move.move">move</a></li><li><a href="#c.move.moveTo">moveTo</a></li></ul></li><li class="nav-header"><a href="#c.tile">c.tile</a><ul></ul></li><li class="nav-header"><a href="#c.collide">c.collide</a><ul><li><a href="#c.collide.findCollisions">findCollisions</a></li></ul></li><li class="nav-header"><a href="#c.layer">c.layer</a><ul></ul></li><li class="nav-header"><a href="#c.tween">c.tween</a><ul><li><a href="#c.tween.tween">tween</a></li></ul></li></ul></li><li class="nav-file"><a href="physics.html">physics</a><ul></ul></li><li class="nav-file"><a href="tiles.html">tiles</a><ul></ul></li><li class="nav-file"><a href="input.html">input</a><ul></ul></li><li class="nav-file"><a href="collision.html">collision</a><ul></ul></li><li class="nav-file"><a href="rogue.html">rogue</a><ul></ul></li></ul></div><div class="container"><header><h1>entity</h1></header><dl class="doc"><dt id="Entity">class Entity</dt><dd><p><p>The main entity class. All entities are based on this.
Components can be added to the entity with <code>entity.components.add</code>
or though the property <code>require</code> on initialization.
Example:
</p>
<pre><code class="prettyprint lang-coffee">myEntity = new Entity({require:&quot;move&quot;})
myEntity.add(&quot;sprite&quot;) # sprite was already imported by move, it is not added a second time
myEntity.add([&quot;collide&quot;,&quot;physics&quot;]) # adding arrays is also supported</code></pre>
<p>New components can be made available to entities by attaching them to <code>Rogue.components.[name]</code>
Entities have an event emitter on <code>ev</code></p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class Entity
  </pre><dl class="doc"><dt id="Entity.constructor">constructor()</dt><dd><p><p>Entity constructor</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>options </b><code>Object</code><span>	the attributes the new entity should have</span></p><ul></ul><li><b>require </b><code>Array</code><span>	components that should be imported on creation</span></li><li><b>parent </b><code>Object</code><span>	the parent of this entity, is set automatically when added to a ViewPort</span></li><li><b>name </b><code>String</code><span>	entity name</span></li></dd></dl><pre class="prettyprint language-coffee">constructor: (options) ->
  @updates=[]    
  util.mixin @, options
  #if @require then @components.add(@require)
  
  @ev = new Eventer @
  @components = new Importer Rogue.components,@
  if @require then @components.add @require</pre><dl class="doc"></dl></dd></dl></dd><dt id="Importer">class Importer</dt><dd><p><p>Importer class. This is not exposed publicly, but is the basis of the component system and the physics behavior system.
The importer allows a class to maintain a list of extensions, in Entities these are called Components, but physics behaviors follow the same system.
The extensions must be objects produced by running a function with &quot;new&quot;.
Any properties/methods of the created object will be mixed in to the target object, apart from the &quot;special&quot; properties <code>onadd</code>, <code>onremove</code> and <code>run</code>.

</p>
<p><code>onadd</code> is an optional function that is called when the extension is added to a target. 
Likewise <code>onremove</code> is called when the extension is removed. This can be used to &quot;clean up&quot; additional properties created with <code>onadd</code>.
<code>run</code> is called on tick if the extension is added to the physics engine. More is explained about this in the physics section.
When an extension is removed from an object, all mixed in properties/methods are removed automatically, unless they have been modified.
If a property is likely to have been changed but is safe to remove, it should be removed in the onremove function.</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class Importer
  constructor: (@from,@dest,@mixin=true) ->
  add: (imports) ->
    imports = [].concat(imports)
    for imp in imports when not @[imp]?
      if @from[imp]?
        @[imp] = new @from[imp]
        if @mixin
          for key,val of @[imp] when (key isnt "onadd" and key isnt "onremove" and key isnt "run" and val?)
            @dest[key] = val
        if @[imp].onadd then @[imp].onadd.call(@dest)
      else log 2,"mixin #{imp} does not exist!"
  remove: (imports) ->
    imports = [].concat(imports)
    for imp in imports when @[imp]?
      if @mixin
        for key,val of @[imp] when @dest[key]? and @dest[key] is @[imp][key]
          delete @dest[key]
      if @[imp].onremove then @[imp].onremove.call(@dest)
      delete @[imp]</pre><dl class="doc"></dl></dd><dt id="Factory">class Factory</dt><dd><p><p>an Entity factory class. This can be used to hold a group of pre-built entities to reduce
the time spend building fast spawning entities dynamically, eg. bullets.
If you set the &quot;parent&quot; property on entities created in a factory, then they will be automatically added/removed from the parent
using its (the parents) <code>add()</code> and <code>remove()</code> functions. This makes sense if the parent is a ViewPort</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class Factory
  </pre><dl class="doc"><dt id="Factory.constructor">constructor()</dt><dd><p><p>Factory Constructor</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>options </b><code>Object</code><span>	the options for this factory</span></p><ul></ul><li><b>entity </b><code>Entity</code><span>	(optional) the entity to manufacture</span></li><li><b>options </b><code>Object</code><span>	the options to use when creating the entity</span></li><li><b>initial </b><code>Int</code><span>	the initial number of entities to build</span></li></dd></dl><pre class="prettyprint language-coffee">constructor: (options) ->
  @hanger = []
  @entity = options.entity or Rogue.Entity
  @opts = options.options or {}
  @initial = options.initial
  for i in [0...@initial]
    @hanger.push @build()</pre><dl class="doc"></dl></dd><dt id="Factory.deploy">deploy()</dt><dd><p><p>Take a single entity from the factory, create a new one only if none are available. The new entity has a <code>return()</code> function
that should be called when it is no longer needed. Entities produced by a factory cannot be guaranteed to be &quot;clean&quot; so it is best
to manually reinitialize important variables. The original options will be re-mixed in.</p>
</p><dl class="dl-horizontal"><dt>Returns:</dt><dd><code>Entity</code><span>	a new entity</span></dd></dl><pre class="prettyprint language-coffee">deploy: ->
  if @hanger.length > 0
    e = @hanger.pop()
  else 
    e = @build()
  if e.parent then e.parent.add e
  e</pre><dl class="doc"></dl></dd></dl></dd><dt id="c.sprite">class c.sprite</dt><dd><p><p>Sprite component. Entities with this component require an image property. 
Sprites have x and y coordinates, which default to 0. They also support angle and opacity properties
If a entity is initialized with a scaleFactor property, then it will be scaled on creation.</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class c.sprite
  onadd: ->
    unless @image then log 2, "Sprite entities require an image"
    @x ?= 0
    @y ?= 0
    @angle ?= 0
    @opacity ?= 255
    if @scaleFactor? then @scale @scaleFactor, @pixel else @recalculateImage()
  </pre><dl class="doc"><dt id="c.sprite.draw">draw()</dt><dd><p><p>Draw the entity. This function should be ran at the end of each tick
If the entity is a child of a viewport, then this will be called automatically.</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">draw: ->
  c = @parent.context
  r = math.round
  c.save()
  c.translate(r(@x-@xOffset), r(@y-@yOffset))
  c.rotate(@angle*Math.PI/180)
  c.globalAlpha = @opacity
  c.drawImage(@image, 0, 0, @width, @height)
  c.restore()</pre><dl class="doc"></dl></dd><dt id="c.sprite.scale">scale()</dt><dd><p><p>Scale the entity by a scale factor. Optionally use &quot;pixel perfect&quot; nearest neighbor scaling</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>scaleFactor </b><code>Array</code><span>	the factors to scale the dimensions by</span></p><p> <b>pixel </b><code>Bool</code><span>	use nearest neighbor scaling</span></p></dd></dl><pre class="prettyprint language-coffee">scale: (@scaleFactor, @pixel) ->
  @image = gfx.scale @image,@scaleFactor,@pixel
  @recalculateImage()</pre><dl class="doc"></dl></dd><dt id="c.sprite.rect">rect()</dt><dd><p><p>Used to calculate a AABB around the entity.</p>
</p><dl class="dl-horizontal"><dt>Returns:</dt><dd><code>Rect</code><span>	A rect has x,y,width and height properties</span></dd></dl><pre class="prettyprint language-coffee">rect: ->
  x: @x-@xOffset
  y: @y-@yOffset
  width: @width
  height: @height</pre><dl class="doc"></dl></dd></dl></dd><dt id="c.move">class c.move</dt><dd><p><p>Move component. Adds the sprite component on add, as only drawable things can move
Provided methods for moving.</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class c.move
  onadd: ->
    @components.add "sprite"</pre><dl class="doc"><dt id="c.move.move">move()</dt><dd><p><p>Adds x,y to the current position</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>x </b><code>Int</code><span>	</span></p><p> <b>y </b><code>Int</code><span>	</span></p></dd></dl><pre class="prettyprint language-coffee">move: (x,y) ->
  @x += x
  @y += y</pre><dl class="doc"></dl></dd><dt id="c.move.moveTo">moveTo()</dt><dd><p><p>Sets the current position to x,y</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>x </b><code>Int</code><span>	</span></p><p> <b>y </b><code>Int</code><span>	</span></p></dd></dl><pre class="prettyprint language-coffee">moveTo: (@x,@y) -></pre><dl class="doc"></dl></dd></dl></dd><dt id="c.tile">class c.tile</dt><dd><p><p>Tile component. Overrides move() and moveTo() to versions 
friendly for entities part of a TileMap</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class c.tile
  onadd: ->
    @components.add "sprite"</pre><dl class="doc"></dl></dd><dt id="c.collide">class c.collide</dt><dd><p><p>Collision component. Adds this entity to the collidables of the parent, so other entities will
account for it in there collision detection.
Provides methods for finding collisions with this entity, and &quot;hit&quot; events will be emitted on contact with other collidables
Overrides the entities move function with one that will only move as far as it can without colliding.
In addition to having this component, collidable entities need to have a component that provides a <code>collide(ent)</code> function
that will test for collisions with the entity ent.
AABB and hitmap components are built in.</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class c.collide
  onadd: ->
    unless @components["layer"]? then @components.add "sprite"
    @solid = if @components["physics"]? then false else true</pre><dl class="doc"><dt id="c.collide.findCollisions">findCollisions()</dt><dd><p><p>finds all entities that are colliding with us.</p>
</p><dl class="dl-horizontal"><dt>Returns:</dt><dd><code>Array</code><span>	an array of collisions. Collisions are in the form {e1,e2,dir,pv} where dir is the rough direction of collision and pv is the penetration vector.</span></dd></dl><pre class="prettyprint language-coffee">findCollisions: ->
  if @parent.hashmap
    nearby = @parent.hashmap.find @
  else nearby = @parent.find ["collide"]
  @colliding = []
  for obj in nearby
    col = @collide obj
    if col
      @ev.emit "hit",col
      obj.ev.emit "hit",col
      @colliding.push col
  return @colliding</pre><dl class="doc"></dl></dd></dl></dd><dt id="c.layer">class c.layer</dt><dd><p><p>Layer components. &quot;Converts&quot; an entity into a parallax layer. 
Extends sprite, so support all the same options plus:</p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>properties </b><code></code><span>	</span></p><ul></ul><li><b>speed </b><code>Int</code><span>	the move speed of this layer</span></li><li><b>repeatX </b><code>Bool</code><span>	should this layer tile on the x-axis?</span></li><li><b>repeatY </b><code>Bool</code><span>	should this layer tile on the y-axis?</span></li><li><b>scrollX </b><code>Bool</code><span>	should this layer scroll on the x-axis?</span></li><li><b>scrollY </b><code>Bool</code><span>	should this layer scroll on the y-axis?</span></li></dd></dl><pre class="prettyprint language-coffee">class c.layer extends c.sprite
  onadd: ->
    @width ?= @image.width
    @height ?= @image.height
    @x ?= 0
    @y ?= 0
    @opacity ?= 255
    @angle ?= 0
    @xOffset = @yOffset = 0
    if @scaleFactor then @scale @scaleFactor
    @repeatX ?= false
    @repeatY ?= false
    @scrollY ?= false
    @scrollX ?= true
    @speed ?= 0
  draw: (x=0, y=0)->
    rect = @parent.rect()
    r = math.round
    unless x > 0 or y > 0
      if @scrollX then @x = math.round(rect.x*@speed)
      if @scrollY then @y = math.round(rect.y*@speed)
    c = @parent.context
    c.save()
    c.rotate(@angle*Math.PI/180)
    c.globalAlpha = @opacity
    c.translate(r(@x+x),r(@y+y))
    c.drawImage(@image, 0, 0, @width, @height)
    c.restore()
    if @repeatX and @x+@width+x < rect.x+rect.width
      @draw(x+@width,0)
    if @repeatY and @y+@height+y < rect.y+rect.height
      @draw(0,y+@height)</pre><dl class="doc"></dl></dd><dt id="c.tween">class c.tween</dt><dd><p><p>Adds tween support to an entity. All tweens are applied on update, 
and are automatically removed when done.</p>
</p><dl class="dl-horizontal"></dl><pre class="prettyprint language-coffee">class c.tween
  onadd: -> 
    @tweening = false
    @tweens = []
    @updates.push applytweens
  onremove: ->
    util.remove @updates,applytweens   </pre><dl class="doc"><dt id="c.tween.tween">tween()</dt><dd><p><p>Tween properties to certain values. Smoothly animate the properties to <code>props</code> over time <code>time</code>
Only supports numeric values. 
Optionally takes a callback to execute when done. </p>
</p><dl class="dl-horizontal"><dt>Parameters:</dt><dd><p> <b>props </b><code>Object</code><span>	final values of properties to adjust</span></p><p> <b>time </b><code>Int</code><span>	in seconds to animate over.</span></p></dd></dl><pre class="prettyprint language-coffee">tween: (props, time, cb) ->
  @tweens.push new Tween(@,props,time,cb)
  return @</pre><dl class="doc"></dl></dd></dl></dd></dl></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script><script src="libs/prettify.js"></script><script>$(function(){prettyPrint()})
</script></body></html>